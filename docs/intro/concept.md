# 設計コンセプト

本プロジェクトの設計を貫く考え方と、採用したアーキテクチャの概要を示す。

---

## AI駆動開発

### AIが主な開発者

本プロジェクトでは、人間がコードを書く比率よりも AI（LLM）がコードを書く比率の方が高いことを前提とする。
AI はセッションをまたぐとメモリがリセットされるため、**ソースコードとドキュメントが AI の唯一の記憶媒体**となる。

### ソースコードをコンテキストとして使う

AI が生成するコードの品質は、注入されるコンテキストの品質に直接依存する。
ドキュメントと同様に、**リポジトリ内のソースコードも AI への例示として機能する**。
セッション開始時にコードを読み込んだ AI は、そのコードのスタイル・設計判断・命名規則を暗黙の規範として採用する傾向がある。

いわゆる **Garbage in, garbage out** の原則がここにも働く。
低品質なコードを例示すれば AI は低品質なコードを生成し、高品質なコードを例示すれば AI は高品質なコードを生成しやすくなる。
そのため本リポジトリのリファレンス実装は、AI に真似させることを意識して徹底的にリファクタリングされている。

### ドキュメントをコンテキストとして使う

AI がセッション開始時に読み込むドキュメントが、そのまま設計判断の根拠になる。
「何があるか」だけでなく「なぜそう設計したか」を明示することで、AI が合理的に見える別の設計に逸れるリスクを防ぐ。

### llms.txt の位置付け

`llms.txt` はプロジェクトルートに置くドキュメントインデックスである。
AI はタスク開始時にまずここを読み、次に対象タスクに関連するドキュメントを読んでからコードを変更する。
ドキュメントとコードを同期させ続けることで、AI が常に正確なコンテキストを得られる状態を維持する。

---

## Onion Architecture（オニオンアーキテクチャ）

### 構成概要

本プロジェクトは **2つの層** と **Shared Kernel** で構成される。

```
        ┌───────────────────────┐
        │ CLI層                 │ ← 最外殻
        │  ┌─────────────────┐  │
        │  │ ビジネスロジック層│  │ ← 最内殻（中核）
        │  └─────────────────┘  │
        └───────────────────────┘
            ↑ 両層から参照
        ┌───────────────────────┐
        │ 基盤（foundation）    │ ← Shared Kernel（横断的共通部品）
        │（FS・エラー・ログ等）  │
        └───────────────────────┘
```

| レイヤー / 区分 | 責務の概要 |
|---|---|
| **CLI層** | コマンドライン処理、実行時コンテキストの組み立て、エラーハンドリング |
| **ビジネスロジック層** | 全体処理制御、ドメイン固有の処理 |
| **基盤（Shared Kernel）** | 横断的共通部品（FS・エラー処理・ログ・データモデル基盤） |

### 採用理由

- **依存の単方向性**: 依存は常に外側 → 内側（CLI → ビジネスロジック）。内側の層は外側を知らない。循環依存は禁止。
- **テスタビリティ**: 副作用を Protocol で抽象化し、テスト時にモック／スタブに差し替えられる。
- **技術独立性**: 外部システム（DB・外部 API 等）の変更がビジネスロジックに影響しない。

### 基盤（foundation）は層ではない

`基盤（foundation）` は Onion Architecture の「層」ではなく、**Shared Kernel（横断的共通部品）** である。
CLI層・ビジネスロジック層の両方から参照される共通部品として位置付けており、特定の機能に属さない安定した抽象のみを置く。

---

## Composition Root + Orchestrator パターン

### Provider（静的な依存グラフ構築）

Provider は Composition Root として機能する。アプリケーションのエントリーポイント近くで、必要な依存関係（外部 API クライアント・ファイル I/O 等）をまとめて初期化し、Orchestrator に注入する唯一の場所である。
ビジネスロジック層は具象クラスを直接参照しない。

### Orchestrator（処理フロー制御）

Orchestrator はビジネスロジックの処理フロー全体を制御する。CLI・REST API 等のエントリーポイントから独立しており、受け取った Context（実行時パラメータを保持する不変オブジェクト）のみに依存して処理を実行する。

### 採用理由

- 依存関係を一箇所（Composition Root）に集約することで、依存性注入を明示的に管理できる。
- Orchestrator をエントリーポイントから分離することで、インターフェース変更時もビジネスロジック層は変更不要になる。

---

## ドキュメント戦略

各ディレクトリの役割を明確に分離し、情報の重複を避ける。

| ディレクトリ / ファイル | 対象の関心 | 目的 |
|---|---|---|
| `docs/intro/` | **Why**（なぜこう設計するか） | 設計思想・コンセプトの導入。新規参加者や AI が最初に読む |
| `docs/design/` | **What**（何を・どう設計するか） | アーキテクチャ設計・コーディング規約の全体像 |
| `docs/specs/` | **How**（各モジュールをどう実装するか） | モジュール単位の要件定義・基本設計。AI へのコンテキスト提供が主目的 |
| `llms.txt` | **インデックス** | AI がタスク開始時に最初に参照するドキュメント一覧 |

### 重複を避ける原則

- `intro/` は概要と採用理由に留め、詳細は `design/` へのリンクで参照する。
- `specs/` はモジュール固有の情報のみを記述し、アーキテクチャ全体の説明は `design/` に委ねる。
- `llms.txt` は索引であり、内容そのものは記述しない。

---

## リファレンス実装

### 範囲と位置付け

`src/example/` 配下のすべて（`cli.py`・`config/`・`foundation/`・`transform/`）がリファレンス実装である。
CLI の書き方から基盤コンポーネントまで、新規プロジェクトへそのまま流用できる品質を持つ。
また `tests/` 配下もテストコードのリファレンス実装として位置付ける。

なかでも `transform` パッケージは、Onion Architecture と Composition Root + Orchestrator パターンの全要素を網羅した雛形であり、新しい機能パッケージを追加する際に最初に参照する。

### 構成要素の概説

| コンポーネント | ファイル | 役割 |
|---|---|---|
| CLI エントリーポイント | `src/example/cli.py` | Config・Context・Provider を組み立て、Orchestrator に委譲 |
| 設定 | `src/example/config/` | 環境変数・パス・AppConfig の3層で設定を組み立てる |
| 基盤（Shared Kernel） | `src/example/foundation/` | エラー・FS・ログ・モデル基盤などの横断的共通部品 |
| Context | `src/example/transform/context.py` | 実行時パラメータを不変オブジェクトとして保持 |
| Orchestrator | `src/example/transform/orchestrator.py` | 処理フロー全体を制御 |
| Provider | `src/example/transform/provider.py` | Composition Root。依存グラフを構築して Orchestrator を生成 |
| Reader / Writer | `src/example/transform/reader.py` / `writer.py` | Protocol 経由の薄いラッパー |
| Result types | `src/example/transform/types.py` | 処理結果・値オブジェクト |
| テストコード | `tests/` | 各パッケージに対応したテストのリファレンス実装 |
