# 設計コンセプト

本プロジェクトの設計を貫く考え方と、AI駆動開発を実現するための設計哲学を示す。

---

## AI駆動開発

### AIが主な開発者

本プロジェクトでは、人間がコードを書く比率よりも AI（LLM）がコードを書く比率の方が高いことを前提とする。
AI はセッションをまたぐとメモリがリセットされるため、**ソースコードとドキュメントが AI の唯一の記憶媒体**となる。

### ソースコードをコンテキストとして使う

AI が生成するコードの品質は、注入されるコンテキストの品質に直接依存する。
ドキュメントと同様に、**リポジトリ内のソースコードも AI への例示として機能する**。
セッション開始時にコードを読み込んだ AI は、そのコードのスタイル・設計判断・命名規則を暗黙の規範として採用する傾向がある。

いわゆる **Garbage in, garbage out** の原則がここにも働く。
低品質なコードを例示すれば AI は低品質なコードを生成し、高品質なコードを例示すれば AI は高品質なコードを生成しやすくなる。
そのため本リポジトリのリファレンス実装は、AI に真似させることを意識して徹底的にリファクタリングされている。

### ドキュメントをコンテキストとして使う

AI がセッション開始時に読み込むドキュメントが、そのまま設計判断の根拠になる。
「何があるか」だけでなく「なぜそう設計したか」を明示することで、AI が合理的に見える別の設計に逸れるリスクを防ぐ。

---

## SDD（Spec-Driven Development）とコンテキストエンジニアリング

### SDDの考え方

AI がコードを書く前に、`llms.txt` を起点として `docs/specs/` を読み、仕様を理解してから実装する手法を **SDD（Spec-Driven Development）** と呼ぶ。
仕様書が実装の前提条件となることで、AI は設計意図に沿ったコードを生成できる。

### コンテキストエンジニアリング

適切な順番・粒度でドキュメントを提供することで、AI の判断精度を上げる設計を **コンテキストエンジニアリング** と呼ぶ。
「何を、いつ、どの粒度で渡すか」を意識的に設計することが、AI 駆動開発の品質を左右する。

### ドキュメント階層とllms.txt

`docs/intro/`（Why）→ `docs/design/`（What）→ `docs/specs/`（How）→ `llms.txt`（Index）という階層構造がこれを支える。
`llms.txt` はこの流れのエントリーポイントであり、タスク種別に応じた「読むべきドキュメントのガイド」として機能する。
AI はタスク開始時にまずここを読み、次に対象タスクに関連するドキュメントを読んでからコードを変更する。

### コンテキストの層

このリポジトリのファイル群は、AI へ渡すコンテキストを役割ごとに分離した「層」として設計されている。
各層は独立した更新頻度と読み込みタイミングを持ち、セッションごとに必要な層だけを選んで参照する。

| 層 | 具体的なファイル | 役割 |
|---|---|---|
| ルール層 | `CLAUDE.md` | コーディング規約・禁止事項・設計原則。変更頻度が低く、常に適用される |
| インデックス層 | `llms.txt` | タスク種別に応じた「読むべきドキュメントのガイド」 |
| 根拠層 | `docs/specs/` | モジュール単位の仕様。タスクごとに読む対象が変わる |
| 例示層 | `src/example/` | ソースコードそのものが AI への設計例示として機能する |

---

## 設計哲学

本プロジェクトが重視する設計目標と基本原則の概要を示す。詳細は [architecture.md](../design/architecture.md) を参照。

### 設計目標

1. **技術独立性**: 外部システムの変更がビジネスロジックに影響しない
2. **テスタビリティ**: 外部 API や I/O をモックに差し替えてテスト可能
3. **変更容易性**: 各機能を独立して進化可能
4. **可読性と保守性**: 各層の責務を明確にし、影響範囲を限定

### 基本原則

実装判断で迷ったら最初に立ち返る代表的な原則：

- **KISS（Keep It Simple, Stupid）**: シンプルな設計を優先、過度な抽象化を避ける
- **YAGNI（You Aren't Gonna Need It）**: 今必要な最小限のみを実装
- **Fail Fast**: 失敗は早く顕在化させる、境界でバリデーション
- **明示は暗黙に勝る（Explicit is better than implicit）**: 暗黙の動作より明示的な設計を優先

---

## 開発規律

本プロジェクトが守る開発規律の概要を示す。詳細は [workflow.md](../design/workflow.md) を参照。

### 代表的な規律

- **TDD（テストファースト）**: 実装コードより先にテストを書く。Red → Green → Refactor のサイクルを守る
- **カバレッジ 100%**: 未カバーのコードは残さない
- **型ヒント必須**: すべての関数・メソッドに型ヒントを付ける

### 開発フローの3フェーズ

1. **理解フェーズ**: `llms.txt` を読み、対象モジュールの `docs/specs/` を確認する
2. **TDD サイクル**: Red → Green → Refactor を小さく回す
3. **後処理**: `make all` が全て通ることを確認し、ドキュメントと実装を同期する

---

## ドキュメント戦略

各ディレクトリの役割を明確に分離し、情報の重複を避ける。

| ディレクトリ / ファイル | 対象の関心 | 目的 |
|---|---|---|
| `docs/intro/` | **Why**（なぜこう設計するか） | 設計思想・コンセプトの導入。新規参加者や AI が最初に読む |
| `docs/design/` | **What**（何を・どう設計するか） | アーキテクチャ設計・コーディング規約の全体像 |
| `docs/specs/` | **How**（各モジュールをどう実装するか） | モジュール単位の要件定義・基本設計。AI へのコンテキスト提供が主目的 |
| `llms.txt` | **インデックス** | AI がタスク開始時に最初に参照するドキュメント一覧 |

### 重複を避ける原則

- `intro/` は概要と採用理由に留め、詳細は `design/` へのリンクで参照する。
- `specs/` はモジュール固有の情報のみを記述し、アーキテクチャ全体の説明は `design/` に委ねる。
- `llms.txt` は索引であり、内容そのものは記述しない。

### コンテキスト窓への外部化

AI のコンテキスト窓は有限であり、すべてのドキュメントを一度に渡すことはできない。
このディレクトリ分離は「重複を避ける」だけでなく、必要な情報をタスクごとに選んで参照できるよう、コンテキスト窓の外部に待機させておく設計でもある。
`llms.txt` がインデックスとして機能することで、AI は「全部読む」のではなく「必要な部分だけ参照する」ことが可能になる。

---

## リファレンス実装

### 範囲と位置付け

`src/example/` 配下のすべて（`cli.py`・`config/`・`foundation/`・`transform/`）がリファレンス実装である。
CLI の書き方から基盤コンポーネントまで、新規プロジェクトへそのまま流用できる品質を持つ。
また `tests/` 配下もテストコードのリファレンス実装として位置付ける。

なかでも `transform` パッケージは、Onion Architecture と Composition Root + Orchestrator パターンの全要素を網羅した雛形であり、新しい機能パッケージを追加する際に最初に参照する。

### 構成要素の概説

| コンポーネント | ファイル | 役割 |
|---|---|---|
| CLI エントリーポイント | `src/example/cli.py` | Config・Context・Provider を組み立て、Orchestrator に委譲 |
| 設定 | `src/example/config/` | 環境変数・パス・AppConfig の3層で設定を組み立てる |
| 基盤（Shared Kernel） | `src/example/foundation/` | エラー・FS・ログ・モデル基盤などの横断的共通部品 |
| Context | `src/example/transform/context.py` | 実行時パラメータを不変オブジェクトとして保持 |
| Orchestrator | `src/example/transform/orchestrator.py` | 処理フロー全体を制御 |
| Provider | `src/example/transform/provider.py` | Composition Root。依存グラフを構築して Orchestrator を生成 |
| Reader / Writer | `src/example/transform/reader.py` / `writer.py` | Protocol 経由の薄いラッパー |
| Result types | `src/example/transform/types.py` | 処理結果・値オブジェクト |
| テストコード | `tests/` | 各パッケージに対応したテストのリファレンス実装 |
