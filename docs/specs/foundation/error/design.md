# foundation/error パッケージ基本設計

[foundation/error パッケージ要件定義](./requirements.md) に基づいた基本設計を説明します。

## アーキテクチャパターン

- **基底クラスパターン**: `ApplicationError` を `Exception` のサブクラスとして定義し、アプリケーション固有の例外を統一の基底型で扱えるようにする
- **責務の単一化**: `ErrorHandler` はログ出力という単一の責務に絞り、プロセス終了制御は呼び出し元に委ねる

## コンポーネント構成

### 主要コンポーネント

| コンポーネント | クラス名 | 役割 |
|---|---|---|
| アプリケーション例外基底クラス | `ApplicationError` | ユーザー向けメッセージと開発者向け詳細を保持する例外の基底 |
| エラーハンドラー | `ErrorHandler` | 例外の種類に応じてフォーマットを切り替えてログ出力する |

### ファイルレイアウト

#### プロダクションコード

```bash
src/example/foundation/error/
├── __init__.py    # 公開 API の定義（ApplicationError, ErrorHandler）
├── error.py       # ApplicationError（アプリケーション例外の基底クラス）
└── handler.py     # ErrorHandler（エラーハンドリング）
```

#### テストコード

```bash
tests/unit/test_foundation/test_error/
└── test_error_handler.py    # ErrorHandler のテスト
```

## 処理フロー

### 全体フロー

1. 呼び出し元から例外を受け取る
2. 例外の種類（アプリケーション例外か汎用例外か）を判別し、それぞれに適したフォーマットでログに記録する
3. ログ出力後、制御を呼び出し元に返す（プロセス終了は行わない）

## 固有の設計判断

### ErrorHandler がプロセス終了を行わない設計

**設計の意図**: `ErrorHandler` は `sys.exit` を呼ばず、ログ記録のみを行い呼び出し元に制御を返す。

**なぜそう設計したか**:

- **テスタビリティ**: `sys.exit` をハンドラ内で呼ぶとユニットテスト実行中にプロセスが終了してしまうため、`foundation/error/` を含むユニットテストレベルでは一切影響が出ないよう設計している。プロセス終了を伴うテストは `tests/integration/test_integration_cli.py` でのみ実施する。
- **柔軟性**: エラー発生後にプロセスを終了するか、処理を継続するか、あるいは別の回復処理を行うかは、アプリケーションの用途によって異なる。エラーハンドラーが自律的にプロセスを終了すると、呼び出し元がエラー後の挙動を制御できなくなる。終了判断を呼び出し元に委ねることで、ハンドラーを様々なコンテキストで使い回せる。

**トレードオフ**: 呼び出し元が `ErrorHandler.handle()` 後にプロセス終了を忘れると、エラー状態のまま処理が継続するリスクがある。終了処理の実装責務は明示的に呼び出し元に持たせる必要がある。

### ユーザー向けメッセージと開発者向け詳細の分離

**設計の意図**: `ApplicationError` はコンストラクタで `message`（ユーザー向け）と `cause`（開発者向け）を分離して受け取り、どちらも `ErrorHandler` がログに記録する。

**なぜそう設計したか**: ユーザーに提示する内容と技術的なデバッグ情報は目的が異なり、単一の文字列に混在させると、ユーザーへの表示時に技術情報が漏れるリスクや、ログから必要情報を抽出しづらくなる問題が生じる。2 つのフィールドに分離することで、表示先に応じた使い分けができる。

**トレードオフ**: `ApplicationError` を継承する側は `message` と `cause` の両方を適切に設定する責任を持つ。`cause` を省略した場合はデフォルト値（`"unexpected error occurred"`）が使われるため、詳細情報が不足したログが生成される可能性がある。

### 例外型による 2 系統のログフォーマット

**設計の意図**: `ErrorHandler` は `ApplicationError` と汎用 `Exception` でログフォーマットを切り替える。`ApplicationError` では独自フィールドの `message`（ユーザー向け）と `cause`（開発者向け詳細、文字列）を活用し、汎用 `Exception` では Python 標準の例外チェーン属性 `__cause__`（`raise X from Y` で設定される例外オブジェクト）を使って根本原因を記録する。

> **注意**: `ApplicationError.cause`（文字列フィールド）と `Exception.__cause__`（Python 標準の例外チェーン属性）は名前が類似しているが別の概念である。

**なぜそう設計したか**: `ApplicationError` は設計上 `message`/`cause` の構造が保証されているため、その情報を最大限活用できる。一方、汎用 `Exception` にはその保証がなく、Python の標準的な例外チェーン（`__cause__`）が唯一の原因情報となる。2 系統に分けることで、どちらの例外も適切な情報量でログに記録できる。

**トレードオフ**: 2 系統のフォーマッターを維持する必要があり、ログフォーマットを変更する際はどちらを変更すべきかを意識する必要がある。

## 制約と注意点

### ErrorHandler の利用スコープ

`ErrorHandler` はグローバルなエラーハンドリングクラスであり、個別の例外を扱うクラスではない。`cli.py` の `main()` のような main 関数近くで利用することを想定しており、他の機能パッケージへの組み込みはスコープ外である。`ApplicationError` と汎用 `Exception` の 2 系統で区別しているのはユーザー体験向上のためであり、これ以外の区別を追加する予定はない。`sys.exit` の呼び出しは呼び出し元（main 関数）で実装すること。

### ログ設定の責務

foundation/error パッケージはロギング設定（ハンドラ・フォーマッタ・ログレベルの設定）を行わない。適切にログが出力されるよう、アプリケーションの起動処理でロギング設定を行う必要がある。

### 公開 API の制限

公開 API は `ApplicationError` と `ErrorHandler` のみ（`__init__.py` の `__all__` で明示）。内部モジュールからの直接 import は行わず、`example.foundation.error` パッケージから import すること。

## 外部依存と拡張性

### 外部システム依存

| 依存先 | 用途 |
|---|---|
| Python `logging` 標準ライブラリ | ロガー取得・ERROR レベルでのログ出力 |

ロガーの設定（ハンドラ・フォーマッタ）はこのパッケージ外で行う。

### 想定される拡張ポイント

- `ApplicationError` を継承して、ドメイン固有のアプリケーション例外クラスを定義できる（例: `ValidationError`, `NotFoundError`）
- `ErrorHandler` を拡張して、エラー通知や外部監視サービスへの送信など、ログ以外の副作用を追加できる

### 拡張時の注意点

- `ApplicationError` のサブクラスを定義する場合、`message` と `cause` を適切に設定することで `ErrorHandler` の既存フォーマットが機能する
- `ErrorHandler` に新たな責務（通知・終了など）を追加する場合、単一責務の原則が損なわれないよう別クラスへの分離を検討すること

## 変更パターン別ガイド

よくある変更ケースと、対応するファイルの道筋を示す。

| 変更内容 | 主な変更対象 | 備考 |
|---|---|---|
| ドメイン固有のアプリケーション例外を追加 | 各パッケージ（`ApplicationError` を継承したサブクラスを定義） | `message` と `cause` を適切に設定することで `ErrorHandler` がそのまま機能する |
| ログフォーマットを変更 | `handler.py` | どの系統（`ApplicationError` か汎用 `Exception` か）を変更すべきかを確認してから実施する |
| 汎用例外のログ出力情報を追加 | `handler.py` | `__cause__` 以外の属性を参照する場合は例外型によって存在しない可能性がある |
| 公開 API を追加 | `__init__.py` の `__all__` | 内部コンポーネントの公開は原則行わない |

## 影響範囲

`ApplicationError` と `ErrorHandler` では影響の方向性が異なる。

**`ApplicationError`**: インターフェイス（プロパティの追加・削除）を変更するとコードベース全体に影響が及ぶ。継承しているすべてのアプリケーション例外クラスおよびその利用箇所が修正対象になるため、変更時は全パッケージへの影響を確認すること。

**`ErrorHandler`**: インターフェイス（`handle()` メソッドのシグネチャ）を変更した場合の影響は、呼び出し箇所（= main 関数近く、基本的に 1 箇所）に集約される。一方、振る舞い（ログフォーマット・出力内容）を変更した場合はアプリケーション全体のエラー時の挙動に影響する。

## 関連ドキュメント

- [foundation/error パッケージ要件定義](./requirements.md): foundation/error パッケージの機能要件や前提条件
- [Python アーキテクチャ設計](../../../design/architecture.md): プロジェクト共通の設計思想
