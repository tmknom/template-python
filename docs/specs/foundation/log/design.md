# foundation/log パッケージ基本設計

[foundation/log パッケージ要件定義](./requirements.md) に基づいた基本設計を説明します。

## アーキテクチャパターン

- **Facade パターン**: `LogConfigurator` が `dictConfig` の複雑なオプション体系を隠蔽し、環境別の設定メソッドとして公開する
- **デコレータパターン**: `log` 関数が Python の関数デコレータとして実装され、横断的関心事であるトレースログを分離する
- **ガードパターン**: `_configure` メソッドの冒頭で既存ハンドラーの有無を確認し、二重初期化を防ぐ

## コンポーネント構成

### 主要コンポーネント

| コンポーネント | クラス名 | 役割 |
| --- | --- | --- |
| ログ設定管理 | `LogConfigurator` | 環境別ログ設定の構築と適用 |
| トレースデコレータ | `log` デコレータ | 関数・メソッドの呼び出しトレース |
| 値フォーマット | `_format_value` 関数 | ログ出力値の要約フォーマット |

### ファイルレイアウト

#### プロダクションコード

```bash
src/example/foundation/log/
├── __init__.py        # 公開 API: LogConfigurator, log
├── configurator.py    # ログ設定管理: LogConfigurator クラス
└── decorator.py       # トレースデコレータ: log デコレータ, _format_value 関数
```

#### テストコード

```bash
tests/unit/test_foundation/test_log/
├── test_configurator.py    # LogConfigurator のテスト
└── test_decorator.py       # log デコレータ / _format_value のテスト
```

## 処理フロー

### ログ設定フロー

1. アプリケーション起動時に一度だけ呼び出す
2. 既存のハンドラーが設定済みであれば早期リターンする（二重初期化防止）
3. 実行環境に応じた設定（出力形式・出力先・ログレベル）を構築し、Python 標準のロギング機構へ適用する

### トレースデコレータフロー

1. デコレートされた関数・メソッドが呼び出されると、関数名（またはクラス名.メソッド名）と引数をログに記録する
2. 元の関数を実行し、戻り値をログに記録して返す
3. 例外が発生した場合はログを出さず、そのまま呼び出し元へ伝播する

### 大量データの要約表示

引数・戻り値が大量データを含む場合、ログの肥大化を防ぐため要約形式で出力する。対象はリスト・タプル・辞書・文字列で、要素数または文字数が閾値を超えた場合に先頭要素と総数を表示する。

閾値の具体的な値は「値フォーマットの閾値定数化」セクションを参照。

## 固有の設計判断

### 環境別設定メソッドの分割

**設計の意図**: `configure_plain()` と `configure_json()` を別メソッドとして公開する設計を採用した。

**なぜそう設計したか**: 呼び出し側に「どの環境用の設定か」を意識させることで、設定ミスを防ぐ。環境名をパラメータとして渡す設計（`configure(env="local")` など）も考えられるが、文字列ではなくメソッド名で意図を表現することで、IDE の補完と型チェックが有効になりコードの可読性が向上する。

**トレードオフ**: 環境が増えるたびにメソッドを追加する必要があるが、環境の種類は通常少数であり問題になりにくい。

### 二重初期化防止のガード処理

**設計の意図**: ロガーに既存ハンドラーが存在する場合は設定を上書きしないガード処理を `_configure` メソッドの冒頭に配置した。

**なぜそう設計したか**: アプリケーションの起動フローにおいて、同じ初期化コードが複数回実行される可能性がある（テストコードの副作用、モジュールの多重インポートなど）。ガードを入れることで、最初に呼び出された設定が確実に有効になり、その後の呼び出しは安全に無視される。

**トレードオフ**: ガードの判定ロジックがハンドラーの有無という実装詳細に依存している。ハンドラーの管理方法を変更する場合は、ガード処理の判定条件も合わせて見直す必要がある。

### dictConfig による設定構築

**設計の意図**: Python 標準の `logging.config.dictConfig` を利用し、設定内容を辞書として動的に組み立てる設計を採用した。

**なぜそう設計したか**: YAML/JSON ファイルによる設定管理も選択肢だが、辞書ベースの構築は Python コード内で完結し、`json_formatter_class` のようなクラスオブジェクトの注入が可能になる。文字列でクラスパスを指定する場合は循環インポートの問題が生じる可能性があるが、クラスオブジェクトを直接渡すことでこれを回避できる。

**トレードオフ**: 設定辞書の構造は `dictConfig` の仕様に依存するため、辞書のキー・値の誤りが実行時エラーとして検出される。型チェックでは事前に検出できない。

### カスタム JSON フォーマッターの注入設計

**設計の意図**: `configure_json()` は `json_formatter_class` を省略可能なパラメータとして受け取り、`logging.Formatter` を継承したクラスを外部から注入できる設計とした。

**なぜそう設計したか**: JSON ログに RequestID などのコンテキスト情報を含めるフォーマッターはアプリケーション層が定義するべき責務であり、Foundation 層である本モジュールに組み込むと依存の逆転が生じる。注入パターンにより、本モジュールは標準フォーマッターで動作しつつ、上位層が必要に応じて拡張できる。

**トレードオフ**: `configure_json` のカスタムフォーマッタークラスは `logging.Formatter` を継承している必要があり、呼び出し元がこの制約を把握していなければならない。

### トレースデコレータの例外非介入設計

**設計の意図**: `log` デコレータは例外が発生した場合にログ出力を行わず、例外をそのまま再送出する設計とした。

**なぜそう設計したか**: 例外処理は `ErrorHandler` のような専用コンポーネントが担うアーキテクチャ方針に従う。デコレータが例外をキャッチしてログ出力した場合、スタックトレースや例外情報の管理が二重になりログが重複する。例外の責務を明確に分離することで、各コンポーネントの役割が単純になる。

**トレードオフ**: デコレートされた関数で例外が発生した場合、トレースログには開始ログのみが記録され終了ログは出力されない。例外発生時の関数呼び出しの完了を追跡したい場合は、別途 `ErrorHandler` のログと突き合わせる必要がある。

### 値フォーマットの閾値定数化

**設計の意図**: `_format_value` で利用するリスト・辞書・文字列の要約閾値を、モジュールレベルの定数として定義した。

**閾値の定義**:

| 対象 | 閾値 | 要約形式 |
| --- | --- | --- |
| リスト・タプル | 10 要素以上 | 先頭 1 要素と総件数 |
| 辞書 | 10 キー以上 | 先頭 1 キー・値ペアと総件数 |
| 文字列 | 100 文字以上 | 先頭部分と総文字数 |

**なぜそう設計したか**: 閾値をコード中に直接埋め込むと変更が困難になる。定数として名前を付けることで意図が明確になり、将来の調整時に変更箇所が一目でわかる。

**トレードオフ**: 閾値定数を変更する場合、既存のログ出力の期待値に影響するためテストの更新が必要になる。

## 制約と注意点

### ログ設定の一回性

`LogConfigurator.configure_plain()` または `configure_json()` はアプリケーション起動時に 1 回だけ呼び出すこと。既存ハンドラーが存在する場合は再設定されないため、後から設定を変更したい場合はプロセスを再起動する必要がある。

### ファイルログの出力先

`configure_plain()` でのファイル出力先は `tmp/logs/` ディレクトリ（カレントディレクトリ相対）に固定されている。このディレクトリが存在しない場合は自動生成される。

### タイムスタンプのタイムゾーン

ログファイル名のタイムスタンプは JST（Asia/Tokyo）で生成される。ログエントリのタイムスタンプは `logging` の標準動作に依存する。

### asyncio ログレベルの固定設定

`LogConfigurator` の設定辞書には `asyncio` ロガーのレベルを `WARNING` に固定するプリセットが含まれる。他のライブラリ（`urllib3` など）についても同様のプリセットを追加することで、ノイズの多いライブラリのログレベルを制御できる。

### クラスメソッド判定の方式と制限

`log` デコレータはクラスメソッドと通常関数を実行時に判定する。判定は「第1引数のオブジェクトが、対象の関数名と同名の属性を持つか」で行われる。

以下のケースでは判定が誤る可能性があるため、`@log` デコレータの適用を避けること:
- `@staticmethod`: 第1引数に `self`/`cls` が存在しないため、クラスメソッドと誤判定される可能性がある
- `@classmethod`: `cls` を第1引数に受け取るが、クラスオブジェクト自体を `self` として扱うため判定ロジックが想定通りに機能しない可能性がある

## 外部依存と拡張性

### 外部システム依存

| 依存先 | 用途 |
| --- | --- |
| Python `logging` 標準ライブラリ | ロガー管理・ハンドラー制御 |
| Python `logging.config` | `dictConfig` による設定適用 |
| `colorlog` ライブラリ | ローカル環境向けカラーフォーマッター |
| `zoneinfo` 標準ライブラリ | ログファイル名のタイムスタンプ生成（JST） |

### 想定される拡張ポイント

- **新規環境向け設定の追加**: `configure_*` メソッドを追加し、`_configure` に引数を渡す形で対応できる
- **フォーマッターの拡張**: `configure_json()` の `json_formatter_class` に新しいフォーマッタークラスを渡すことで、ログフォーマットを変更できる
- **静的メソッドへの対応**: `log` デコレータの引数判定ロジックを拡張することで、`@staticmethod` や `@classmethod` にも対応できる可能性がある
- **ログレベルのカスタマイズ**: 現在 INFO レベルで固定されているトレースログのレベルを設定可能にすることで、より細かな制御が可能になる

### 拡張時の注意点

- `_configure` メソッドの二重初期化防止ロジックは変更しないこと。変更する場合はロガーの状態管理全体を見直す必要がある
- `_format_value` の閾値定数の変更影響については「値フォーマットの閾値定数化」セクションを参照
- `configure_json` のカスタムフォーマッタークラスは `logging.Formatter` を継承している必要がある（「カスタム JSON フォーマッターの注入設計」セクションを参照）

## 変更パターン別ガイド

よくある変更ケースと、対応するファイルの道筋を示す。

| 変更内容 | 主な変更対象 | 備考 |
| --- | --- | --- |
| 新しい環境向け設定を追加 | `configurator.py`（新規 `configure_*` メソッド） | `_configure` の引数として環境固有の設定を渡す |
| ログフォーマットを変更 | `configurator.py`（`_build_dictconfig`） | `dictConfig` の辞書構造を確認してから変更する |
| 値フォーマットの閾値を変更 | `decorator.py`（モジュールレベル定数） | テストの期待値も合わせて更新する |
| トレースログのレベルを変更 | `decorator.py`（`logger.info` の呼び出し箇所） | 開始ログ・終了ログの両方を変更する |
| 公開 API を追加 | `__init__.py` の `__all__` | 内部コンポーネントの公開は原則行わない |

## 影響範囲

foundation/log パッケージが提供する 2 つのコンポーネントは、影響の与え方がまったく異なる。

### `@log` デコレータ

インターフェイス（デコレータ名）を変更すると、コードベース全体への修正が必要になる。`@log` デコレータは全パッケージの関数・メソッドに付与されているため、デコレータ名の変更や引数シグネチャの変更は広範囲に波及する。

一方で振る舞いの変更（ログ出力形式や大量データの要約ロジックなど）は、デコレータが付与されたすべての箇所で自動的に反映されるため、呼び出し元の修正は不要である。

### `LogConfigurator`

インターフェイス（メソッド名・引数）の変更は、アプリケーション起動処理の呼び出し箇所に集約される。`LogConfigurator` はアプリケーション起動時に 1 回だけ呼び出される設計のため、呼び出し元の変更コストは小さい。

一方で振る舞いの変更（ログ出力形式・出力先・ログレベルなど）は、アプリケーション全体のロギング挙動に影響する。設定変更の効果はすべてのコンポーネントのログ出力に及ぶため、意図しない挙動変化が起きないよう十分に確認すること。

## 関連ドキュメント

- [foundation/log パッケージ要件定義](./requirements.md): foundation/log パッケージの機能要件や前提条件
- [Python アーキテクチャ設計](../../../design/architecture.md): プロジェクト共通の設計思想
