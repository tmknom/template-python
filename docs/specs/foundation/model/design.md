# foundation/model パッケージ基本設計

[foundation/model パッケージ要件定義](./requirements.md) に基づいた基本設計を説明します。

## アーキテクチャパターン

- **基底クラスパターン**: `CoreModel` を全ドメインモデルの共通基底として定義し、継承によって共通設定を伝播させる
- **設定オブジェクトパターン**: `ConfigDict` に設定を集約し、設定の変更箇所を単一ファイルに局所化する

## コンポーネント構成

### 主要コンポーネント

| コンポーネント | クラス名 | 役割 |
|---|---|---|
| 共通モデル基底クラス | `CoreModel` | 不変性・厳格バリデーション・文字列正規化・エイリアスサポートを共通設定として保持する基底クラス |

### ファイルレイアウト

#### プロダクションコード

```bash
src/example/foundation/model/
├── __init__.py    # 公開 API の定義（CoreModel）
└── base.py        # CoreModel（共通モデル基底クラス）
```

#### テストコード

```bash
tests/unit/test_foundation/test_model/
└── test_core_model.py    # CoreModel のテスト
```

## 処理フロー

1. ドメインモデルのインスタンス生成時に、Pydantic が CoreModel の共通設定を自動適用する
2. 定義外フィールドの拒否・文字列の空白除去・エイリアス名解決・不変化の各制約が一括で適用される
3. バリデーション違反があれば Pydantic の ValidationError が送出される

## 固有の設計判断

### `frozen=True` による不変オブジェクトの採用

**設計の意図**: `CoreModel` を継承したすべてのドメインモデルのインスタンスを、生成後に変更不可にする。

**なぜそう設計したか**: ドメインモデルは値オブジェクトとして扱うことで、状態変化による副作用を排除し、コードの予測可能性を高める。インスタンスが変更可能だと、関数やメソッド間でのモデルの受け渡し中に値が書き換えられるリスクがあり、バグの追跡が困難になる。不変にすることで、インスタンスがどこで参照されても元の値が保証される。

**トレードオフ**: インスタンス生成後に値を変更したい場合は、新しいインスタンスを生成し直す必要がある。Pydantic の `model_copy()` を使えば部分的な変更を行った新しいインスタンスを生成できるが、呼び出し元での意識的な対応が必要になる。

### `extra="forbid"` による定義外フィールドの拒否

**設計の意図**: モデルのスキーマに定義されていないフィールドを含む入力を受け取った場合、即座にバリデーションエラーを発生させる。

**なぜそう設計したか**: Pydantic のデフォルト動作では定義外フィールドを無視する。これは柔軟だが、入力データに予期しないフィールドが含まれていても気づけないという問題がある。`extra="forbid"` に設定することでモデルのスキーマを明示的な契約として機能させ、意図しないデータの混入をバリデーション段階で早期検出できる。外部 API や他システムとの連携時に、スキーマの不一致を早期に発見できる。

**トレードオフ**: 外部システムからのレスポンスにアプリケーション側で未定義のフィールドが追加された場合、バリデーションエラーになる。外部システムの変更に対してより厳格に対処する必要があり、フィールド追加のたびにモデル定義の更新が求められる。

### `str_strip_whitespace=True` による文字列の自動正規化

**設計の意図**: すべての文字列フィールドに対して、入力値の前後の空白をバリデーション時に自動的に除去する。

**なぜそう設計したか**: 前後の空白を含む文字列は、UI や外部 API からの入力で頻繁に発生するが、アプリケーションのロジックでは余分な空白を含まない正規化された値を期待することが多い。各モデルのフィールドで個別に空白除去を実装すると実装漏れが起きやすく、かつ共通処理のコードが分散する。基底モデルで一元的に有効化することで、すべての文字列フィールドで一貫した動作を保証する。

**トレードオフ**: 意図的に前後の空白を保持したい文字列フィールドが必要になった場合、基底モデルの設定との齟齬が生じる。その場合は、そのモデルのみで上書き設定を行う対応が必要になる。

### `populate_by_name=True` によるエイリアスと内部名の併用

**設計の意図**: フィールドにエイリアスが設定されている場合、エイリアス名と内部名のどちらからでもデシリアライズできるようにする。

**なぜそう設計したか**: Pydantic のデフォルト動作ではエイリアスが設定されたフィールドはエイリアス名のみで受け付けるため、アプリケーション内部の命名規則（snake_case）でインスタンスを生成したい場合に制約となる。外部 API のフィールド名（camelCase など）に対応するエイリアスを定義しつつ、テストや内部処理では内部名を使えることで、可読性と外部互換性の両立が可能になる。

**トレードオフ**: エイリアスと内部名の両方で値を受け付けるため、どちらの名前を使うべきかの規約を別途定める必要がある。

## 制約と注意点

### 公開 API の制限

公開 API は `CoreModel` のみ（`__init__.py` の `__all__` で明示）。内部モジュールからの直接 import は行わず、`example.foundation.model` パッケージから import すること。

### frozen インスタンスの変更

`frozen=True` のインスタンスはフィールド値を直接変更できない。値の一部を変えた新しいインスタンスが必要な場合は、Pydantic が提供する `model_copy(update={...})` を使用すること。

## 外部依存と拡張性

### 外部システム依存

| 依存先 | 用途 |
|---|---|
| Pydantic `BaseModel` | `CoreModel` の基底クラス。バリデーション・シリアライゼーション・不変性の実装を利用する |
| Pydantic `ConfigDict` | `CoreModel` の共通設定を定義するための設定オブジェクト |

### 想定される拡張ポイント

- `CoreModel` にカスタムバリデータを追加することで、アプリケーション全体に適用する共通バリデーションロジックを集中管理できる
- 将来的にシリアライゼーション設定（例: `ser_json_timedelta`、`json_encoders`）が必要になった場合も、`CoreModel` の `ConfigDict` に追加することで全モデルに一括適用できる

### 拡張時の注意点

- `CoreModel` への変更はすべての継承クラスに影響するため、変更前に全テストが通ることを確認すること
- `frozen=True` を廃止または変更すると、アプリケーション全体の不変性の保証が失われるため、慎重に判断すること

## 変更パターン別ガイド

よくある変更ケースと、対応するファイルの道筋を示す。

| 変更内容 | 主な変更対象 | 備考 |
|---|---|---|
| 全ドメインモデルに共通バリデーションを追加 | `base.py`（`CoreModel` にカスタムバリデータを追加） | 全継承クラスに影響するため、全テストが通ることを確認する |
| シリアライゼーション設定を追加 | `base.py`（`ConfigDict` に設定を追加） | Pydantic の `ConfigDict` で利用可能なオプションを確認する |
| ドメインモデルを新規追加 | 各パッケージ（`CoreModel` を継承したクラスを定義） | フィールド定義のみに専念し、共通設定は `CoreModel` から自動適用される |
| 公開 API を追加 | `__init__.py` の `__all__` | 内部コンポーネントの公開は原則行わない |

## 影響範囲

foundation/model パッケージはアプリケーション全体のドメインモデル基盤である。変更時は全パッケージへの影響を確認すること。

- **公開 API の変更**: コードベース全体に影響が及ぶ
- **`CoreModel` の変更**: すべての継承クラスのバリデーション動作・不変性に直接影響する

## 関連ドキュメント

- [foundation/model パッケージ要件定義](./requirements.md): foundation/model パッケージの機能要件や前提条件
- [Python アーキテクチャ設計](../../../design/architecture.md): プロジェクト共通の設計思想
