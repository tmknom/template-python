# Documentation Index

Index for discovering relevant documents during Plan and Explore execution

## Usage

Identify and read task-related sections below:

- Modify `src/example/config/` → Read **Architecture** section and **Specifications > config** section
- Modify `src/example/` → Read **Architecture** and **Source Code** sections
- Modify `tests/` → Read **Architecture** section (testing patterns) and **Python Development** section (packaging, comments)
- Modify `docs/design/` → Read **Architecture** and **Python Development** sections
- Modify `docs/specs/` → Read **Architecture** section and the target **Specifications** section
- Modify `Makefile` → Read **Development Workflow** section
- Modify `CLAUDE.md` or `llms.txt` → Read **Project Configuration** section

## Architecture

- [Architecture design](docs/design/architecture.md): Layered architecture, Composition Root + Orchestrator pattern, Onion Architecture with Protocol-based DI, type design, error handling, and logging - Use when understanding component relationships, adding new features, evaluating design decisions, or implementing new packages
- [specs/ documentation design](docs/design/specs.md): Purpose and design philosophy of specs/ documents for AI-assisted development, authoring guidelines, and operational workflow - Use when creating or updating specs/ documents, understanding why specs/ exists, or reviewing synchronization requirements

## Specifications

### config

- [requirements](docs/specs/config/requirements.md): Functional and quality requirements for the config package — environment variable loading, path construction, and runtime config composition - Use when understanding what the config package must do, verifying implementation correctness, or reviewing acceptance criteria
- [design](docs/specs/config/design.md): Component structure (EnvVarConfig / PathConfig / AppConfig), processing flow, design decisions (3-layer separation, pydantic-settings validation, PathConfig as internal component), and change pattern guide - Use when adding new config fields, changing default value logic, understanding design rationale, or identifying files affected by a change

### cli

- [requirements](docs/specs/cli/requirements.md): Functional requirements and CLI interface spec for the cli module — subcommand execution, global/subcommand-specific options, config priority, error handling, and exit codes - Use when understanding what the cli module must do, verifying implementation correctness, or reviewing acceptance criteria
- [design](docs/specs/cli/design.md): Component structure (app/main_callback/transform/main), two-phase flow (callback→command), design decisions (no business logic, AppConfig in ctx.obj, top-level exception handling), guardrails, and change pattern guide - Use when adding new subcommands, adding CLI options, understanding design rationale, or identifying files affected by a change

### transform

- [requirements](docs/specs/transform/requirements.md): Functional and quality requirements for the transform package — text file reading, line numbering, datetime header, and result statistics - Use when understanding what the transform package must do, verifying implementation correctness, or reviewing acceptance criteria
- [design](docs/specs/transform/design.md): Component structure, processing flow, design decisions (thin wrappers, SrcText/DstText, Fake-based testing), and change pattern guide for the transform package - Use when adding new components, changing transform logic, understanding design rationale, or identifying files affected by a change

## Source Code

### CLI Layer

- [CLI entry point](src/example/cli.py): Typer-based CLI that assembles Config, Context, and OrchestratorProvider then delegates to Orchestrator - Use when adding new commands, understanding the application entry flow, or reviewing how Config/Context/Provider are wired together

### Business Logic Layer

- [Transform feature](src/example/transform/): Reference feature package with Context, Orchestrator, OrchestratorProvider (Composition Root), Reader, Transformer, Writer, and Result types - Use when adding new feature packages, understanding the Orchestrator-Provider-Context pattern, or reviewing the canonical package structure

### Foundation Layer

- [Error handling](src/example/foundation/error/): ApplicationError base class and ErrorHandler - Use when implementing custom errors, understanding exception flow, or modifying error logging
- [Filesystem abstraction](src/example/foundation/fs/): Protocol-based file I/O with TextFileSystemReader - Use when adding new I/O operations, implementing Protocol adapters, or understanding the Port/Adapter pattern
- [Logging](src/example/foundation/log/): `@log` decorator (auto-records args and return values) and LogConfigurator - Use when adding logging to new components, understanding cross-cutting concern implementation, or configuring log output
- [Base model](src/example/foundation/model/): CoreModel for external data mapping - Use when adding new data models for JSON/YAML input or understanding the boundary validation pattern

## Python Development

- [Comment guidelines](docs/design/comment.md): Docstring and inline comment design - Use when writing or reviewing Python code, understanding module/class/method docstring separation, or applying Google-style docstring conventions
- [Packaging guidelines](docs/design/packaging.md): Python packaging and test directory design - Use when adding packages, configuring `__init__.py`, understanding test helper placement, or reviewing pytest/pyright configuration
- [pyproject.toml design](docs/design/pyproject.md): Configuration rationale for build system, linter, and type checker - Use when modifying pyproject.toml settings, understanding ruff/pyright rule choices, or reviewing tool configuration decisions

## Development Workflow

- [Makefile](Makefile): Development commands (sync, fmt, lint, typecheck, test-unit, coverage) - Use when understanding available development commands or modifying the build/test pipeline

## Project Configuration

- [CLAUDE.md](CLAUDE.md): Claude Code project memory and Plan Mode constraints - Use when understanding AI agent behavior rules or modifying project-level memory
- [llms.txt](llms.txt): This document index (for AI agent discovery) - Use when adding new documentation or restructuring project documents
